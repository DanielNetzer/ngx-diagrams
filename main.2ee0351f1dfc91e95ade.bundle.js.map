{"version":3,"file":"main.2ee0351f1dfc91e95ade.bundle.js","sources":["webpack:///./projects/ngx-diagrams/src/lib/containers/diagram/diagram.component.ts"],"sourcesContent":["import {\n\tComponent,\n\tOnInit,\n\tInput,\n\tRenderer2,\n\tOutput,\n\tEventEmitter,\n\tViewChild,\n\tViewContainerRef,\n\tElementRef,\n\tAfterViewInit,\n\tChangeDetectionStrategy\n} from '@angular/core';\nimport { DiagramModel } from '../../models/diagram.model';\nimport { NodeModel } from '../../models/node.model';\nimport { LinkModel } from '../../models/link.model';\nimport { BehaviorSubject, Observable, combineLatest } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { BaseAction, MoveCanvasAction, SelectingAction } from '../../actions';\nimport { BaseModel } from '../../models/base.model';\nimport { MoveItemsAction } from '../../actions/move-items.action';\nimport { PointModel } from '../../models/point.model';\nimport { Coords } from '../../interfaces/coords.interface';\nimport { PortModel } from '../../models/port.model';\nimport { some } from 'lodash';\n\n@Component({\n\tselector: 'ngdx-diagram',\n\ttemplate: require('./diagram.component.html'),\n\tstyles: [require('./diagram.component.scss')],\n\tchangeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class NgxDiagramComponent implements OnInit, AfterViewInit {\n\t// tslint:disable-next-line:no-input-rename\n\t@Input('model') diagramModel: DiagramModel;\n\t@Input() allowCanvasZoon = true;\n\t@Input() allowCanvasTranslation = true;\n\t@Input() inverseZoom = true;\n\t@Input() allowLooseLinks = true;\n\n\t@Output() actionStartedFiring: EventEmitter<BaseAction> = new EventEmitter();\n\t@Output() actionStillFiring: EventEmitter<BaseAction> = new EventEmitter();\n\t@Output() actionStoppedFiring: EventEmitter<BaseAction> = new EventEmitter();\n\n\t@ViewChild('nodesLayer', { read: ViewContainerRef }) nodesLayer: ViewContainerRef;\n\t@ViewChild('linksLayer', { read: ViewContainerRef }) linksLayer: ViewContainerRef;\n\t@ViewChild('canvas', { read: ElementRef }) canvas: ElementRef;\n\n\tprivate nodes$: Observable<{ [s: string]: NodeModel }>;\n\tprivate links$: Observable<{ [s: string]: LinkModel }>;\n\tprivate action$: BehaviorSubject<BaseAction> = new BehaviorSubject(null);\n\tprivate nodesRendered$: BehaviorSubject<boolean>;\n\n\tprivate mouseUpListener = () => {};\n\tprivate mouseMoveListener = () => {};\n\n\tconstructor(private renderer: Renderer2) {}\n\n\t// TODO: handle destruction of container, resseting all observables to avoid memory leaks!\n\n\tngOnInit() {\n\t\tif (this.diagramModel) {\n\t\t\tthis.diagramModel.getDiagramEngine().setCanvas(this.canvas.nativeElement);\n\n\t\t\tthis.nodes$ = this.diagramModel.selectNodes();\n\t\t\tthis.links$ = this.diagramModel.selectLinks();\n\t\t\tthis.nodesRendered$ = new BehaviorSubject(false);\n\n\t\t\tthis.nodes$.subscribe(nodes => {\n\t\t\t\tthis.nodesRendered$.next(false);\n\t\t\t\tObject.values(nodes).forEach(node => {\n\t\t\t\t\tif (!node.getPainted()) {\n\t\t\t\t\t\tthis.diagramModel.getDiagramEngine().generateWidgetForNode(node, this.nodesLayer);\n\t\t\t\t\t\tnode.setPainted();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis.nodesRendered$.next(true);\n\t\t\t});\n\t\t}\n\t}\n\n\tngAfterViewInit() {\n\t\tcombineLatest(this.nodesRendered$, this.links$)\n\t\t\t.pipe(filter(([nodesRendered, _]) => !!nodesRendered))\n\t\t\t.subscribe(([_, links]) => {\n\t\t\t\tObject.values(links).forEach(link => {\n\t\t\t\t\tif (!link.getPainted()) {\n\t\t\t\t\t\tif (link.getSourcePort() !== null) {\n\t\t\t\t\t\t\tconst portCenter = this.diagramModel.getDiagramEngine().getPortCenter(link.getSourcePort());\n\t\t\t\t\t\t\tlink.getPoints()[0].setCoords(portCenter);\n\n\t\t\t\t\t\t\tconst portCoords = this.diagramModel.getDiagramEngine().getPortCoords(link.getSourcePort());\n\t\t\t\t\t\t\tlink.getSourcePort().updateCoords(portCoords);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (link.getTargetPort() !== null) {\n\t\t\t\t\t\t\tconst portCenter = this.diagramModel.getDiagramEngine().getPortCenter(link.getTargetPort());\n\t\t\t\t\t\t\tlink.getPoints()[link.getPoints().length - 1].setCoords(portCenter);\n\n\t\t\t\t\t\t\tconst portCoords = this.diagramModel.getDiagramEngine().getPortCoords(link.getTargetPort());\n\t\t\t\t\t\t\tlink.getTargetPort().updateCoords(portCoords);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.diagramModel.getDiagramEngine().generateWidgetForLink(link, this.linksLayer);\n\t\t\t\t\t\tlink.setPainted();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\t/**\n\t * fire the action registered and notify subscribers\n\t */\n\tfireAction() {\n\t\tif (this.action$.value) {\n\t\t\tthis.actionStillFiring.emit(this.action$.value);\n\t\t}\n\t}\n\n\t/**\n\t * Unregister the action, post firing and notify subscribers\n\t */\n\tstopFiringAction(shouldSkipEvent?: boolean) {\n\t\tif (!shouldSkipEvent) {\n\t\t\tthis.actionStoppedFiring.emit(this.action$.value);\n\t\t}\n\t\tthis.action$.next(null);\n\t}\n\n\t/**\n\t * Register the new action, pre firing and notify subscribers\n\t */\n\tstartFiringAction(action: BaseAction) {\n\t\tthis.action$.next(action);\n\t\tthis.actionStartedFiring.emit(action);\n\t}\n\n\tselectAction() {\n\t\treturn this.action$;\n\t}\n\n\tshouldDrawSelectionBox() {\n\t\tconst action = this.action$.getValue();\n\t\tif (action instanceof SelectingAction) {\n\t\t\taction.getBoxDimensions();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetMouseElement(event: MouseEvent): { model: BaseModel; element: Element } {\n\t\tconst target = event.target as Element;\n\n\t\t// is it a port?\n\t\tlet element = target.closest('[data-portid]');\n\t\tif (element) {\n\t\t\t// get the relevant node and return the port.\n\t\t\tconst nodeEl = target.closest('[data-nodeid]');\n\t\t\treturn {\n\t\t\t\tmodel: this.diagramModel.getNode(nodeEl.getAttribute('data-nodeid')).getPort(element.getAttribute('data-portid')),\n\t\t\t\telement\n\t\t\t};\n\t\t}\n\n\t\t// look for a point\n\t\telement = target.closest('[data-pointid]');\n\t\tif (element) {\n\t\t\treturn {\n\t\t\t\tmodel: this.diagramModel.getLink(element.getAttribute('data-linkid')).getPointModel(element.getAttribute('data-pointid')),\n\t\t\t\telement\n\t\t\t};\n\t\t}\n\n\t\t// look for a link\n\t\telement = target.closest('[data-linkid]');\n\t\tif (element) {\n\t\t\treturn {\n\t\t\t\tmodel: this.diagramModel.getLink(element.getAttribute('data-linkid')),\n\t\t\t\telement\n\t\t\t};\n\t\t}\n\n\t\t// a node maybe\n\t\telement = target.closest('[data-nodeid]');\n\t\tif (element) {\n\t\t\treturn {\n\t\t\t\tmodel: this.diagramModel.getNode(element.getAttribute('data-nodeid')),\n\t\t\t\telement\n\t\t\t};\n\t\t}\n\n\t\t// just the canvas\n\t\treturn null;\n\t}\n\n\tonMouseUp = (event: MouseEvent) => {\n\t\tconst diagramEngine = this.diagramModel.getDiagramEngine();\n\t\tconst action = this.action$.getValue();\n\n\t\t// are we going to connect a link to something?\n\t\tif (action instanceof MoveItemsAction) {\n\t\t\tconst element = this.getMouseElement(event);\n\t\t\taction.selectionModels.forEach(model => {\n\t\t\t\t// only care about points connecting to things\n\t\t\t\tif (!(model.model instanceof PointModel)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (element && element.model instanceof PortModel && !diagramEngine.isModelLocked(element.model)) {\n\t\t\t\t\tconst link = model.model.getLink();\n\t\t\t\t\tif (link.getTargetPort() !== null) {\n\t\t\t\t\t\t// if this was a valid link already and we are adding a node in the middle, create 2 links from the original\n\t\t\t\t\t\tif (link.getTargetPort() !== element.model && link.getSourcePort() !== element.model) {\n\t\t\t\t\t\t\tconst targetPort = link.getTargetPort();\n\t\t\t\t\t\t\tconst newLink = link.clone({});\n\t\t\t\t\t\t\tnewLink.setSourcePort(element.model);\n\t\t\t\t\t\t\tnewLink.setTargetPort(targetPort);\n\t\t\t\t\t\t\tlink.setTargetPort(element.model);\n\t\t\t\t\t\t\ttargetPort.removeLink(link);\n\t\t\t\t\t\t\tnewLink.removePointsBefore(newLink.getPoints()[link.getPointIndex(model.model)]);\n\t\t\t\t\t\t\tlink.removePointsAfter(model.model);\n\t\t\t\t\t\t\tdiagramEngine.getDiagramModel().addLink(newLink);\n\t\t\t\t\t\t\t// if we are connecting to the same target or source, destroy tweener points\n\t\t\t\t\t\t} else if (link.getTargetPort() === element.model) {\n\t\t\t\t\t\t\tlink.removePointsAfter(model.model);\n\t\t\t\t\t\t} else if (link.getSourcePort() === element.model) {\n\t\t\t\t\t\t\tlink.removePointsBefore(model.model);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlink.setTargetPort(element.model);\n\t\t\t\t\t}\n\t\t\t\t\t// delete this.props.diagramEngine.linksThatHaveInitiallyRendered[link.getID()];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// check for / destroy any loose links in any models which have been moved\n\t\t\tif (!this.allowLooseLinks) {\n\t\t\t\taction.selectionModels.forEach(model => {\n\t\t\t\t\t// only care about points connecting to things\n\t\t\t\t\tif (!(model.model instanceof PointModel)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst selectedPoint: PointModel = model.model;\n\t\t\t\t\tconst link: LinkModel = selectedPoint.getLink();\n\t\t\t\t\tif (link.getSourcePort() === null || link.getTargetPort() === null) {\n\t\t\t\t\t\tlink.destroy();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// destroy any invalid links\n\t\t\taction.selectionModels.forEach(model => {\n\t\t\t\t// only care about points connecting to things\n\t\t\t\tif (!(model.model instanceof PointModel)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst link: LinkModel = model.model.getLink();\n\t\t\t\tconst sourcePort: PortModel = link.getSourcePort();\n\t\t\t\tconst targetPort: PortModel = link.getTargetPort();\n\t\t\t\tif (sourcePort !== null && targetPort !== null) {\n\t\t\t\t\tif (!sourcePort.canLinkToPort(targetPort)) {\n\t\t\t\t\t\t// link not allowed\n\t\t\t\t\t\tlink.destroy();\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tsome(\n\t\t\t\t\t\t\tObject.values(targetPort.getLinks()),\n\t\t\t\t\t\t\t(l: LinkModel) => l !== link && (l.getSourcePort() === sourcePort || l.getTargetPort() === sourcePort)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\t// link is a duplicate\n\t\t\t\t\t\tlink.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.stopFiringAction();\n\t\t} else {\n\t\t\tthis.stopFiringAction();\n\t\t}\n\n\t\tthis.mouseUpListener();\n\t\tthis.mouseMoveListener();\n\t\tthis.action$.next(null);\n\t};\n\n\tonMouseMove = (event: MouseEvent) => {\n\t\tconst action = this.action$.getValue();\n\n\t\tif (action === null || action === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (action instanceof SelectingAction) {\n\t\t\tconst relative = this.diagramModel.getDiagramEngine().getRelativePoint(event.clientX, event.clientY);\n\n\t\t\tObject.values(this.diagramModel.getNodes()).forEach(node => {\n\t\t\t\tif ((action as SelectingAction).containsElement(node.getCoords(), this.diagramModel)) {\n\t\t\t\t\tnode.setSelected();\n\t\t\t\t} else {\n\t\t\t\t\tnode.setSelected(false);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tObject.values(this.diagramModel.getLinks()).forEach(link => {\n\t\t\t\tlet allSelected = true;\n\t\t\t\tlink.getPoints().forEach(point => {\n\t\t\t\t\tif ((action as SelectingAction).containsElement(point.getCoords(), this.diagramModel)) {\n\t\t\t\t\t\tpoint.setSelected();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoint.setSelected(false);\n\t\t\t\t\t\tallSelected = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (allSelected) {\n\t\t\t\t\tlink.setSelected();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\taction.mouseX2 = relative.x;\n\t\t\taction.mouseY2 = relative.y;\n\n\t\t\tthis.fireAction();\n\t\t\tthis.action$.next(action);\n\t\t\treturn;\n\t\t} else if (action instanceof MoveItemsAction) {\n\t\t\tconst coords: Coords = {\n\t\t\t\tx: event.clientX - action.mouseX,\n\t\t\t\ty: event.clientY - action.mouseY\n\t\t\t};\n\t\t\tconst amountZoom = this.diagramModel.getZoomLevel() / 100;\n\n\t\t\taction.selectionModels.forEach(model => {\n\t\t\t\t// in this case we need to also work out the relative grid position\n\t\t\t\tif (model.model instanceof NodeModel || (model.model instanceof PointModel && !model.model.isConnectedToPort())) {\n\t\t\t\t\tconst newCoords = { x: model.initialX + coords.x / amountZoom, y: model.initialY + coords.y / amountZoom };\n\t\t\t\t\tmodel.model.setCoords(this.diagramModel.getGridPosition(newCoords));\n\n\t\t\t\t\tif (model.model instanceof NodeModel) {\n\t\t\t\t\t\t// update port coordinates as well\n\t\t\t\t\t\tObject.values(model.model.getPorts()).forEach(port => {\n\t\t\t\t\t\t\tconst portCoords = this.diagramModel.getDiagramEngine().getPortCoords(port);\n\t\t\t\t\t\t\tport.updateCoords(portCoords);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else if (model.model instanceof PointModel) {\n\t\t\t\t\t// we want points that are connected to ports, to not necessarily snap to grid\n\t\t\t\t\t// this stuff needs to be pixel perfect, dont touch it\n\t\t\t\t\tconst newCoords = this.diagramModel.getGridPosition({ x: coords.x / amountZoom, y: coords.y / amountZoom });\n\t\t\t\t\tmodel.model.setCoords({ x: model.initialX + newCoords.x, y: model.initialY + newCoords.y });\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.fireAction();\n\t\t} else if (action instanceof MoveCanvasAction) {\n\t\t\tif (this.allowCanvasTranslation) {\n\t\t\t\tthis.diagramModel.setOffset(\n\t\t\t\t\taction.initialOffsetX + (event.clientX - action.mouseX),\n\t\t\t\t\taction.initialOffsetY + (event.clientY - action.mouseY)\n\t\t\t\t);\n\t\t\t\tthis.fireAction();\n\t\t\t}\n\t\t}\n\t};\n\n\tonMouseDown(event: MouseEvent) {\n\t\tif (event.button === 3) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.diagramModel.clearSelection();\n\n\t\tconst selectedModel = this.getMouseElement(event);\n\n\t\t// canvas selected\n\t\tif (selectedModel === null) {\n\t\t\t// multiple selection\n\t\t\tif (event.shiftKey) {\n\t\t\t\t// initiate multiple selection selector\n\t\t\t\tconst relative = this.diagramModel.getDiagramEngine().getRelativePoint(event.clientX, event.clientY);\n\t\t\t\tthis.startFiringAction(new SelectingAction(relative.x, relative.y));\n\t\t\t} else {\n\t\t\t\t// drag canvas action\n\t\t\t\tthis.diagramModel.clearSelection();\n\t\t\t\tthis.startFiringAction(new MoveCanvasAction(event.clientX, event.clientY, this.diagramModel));\n\t\t\t}\n\t\t} else if (selectedModel.model instanceof PortModel) {\n\t\t\t// its a port element, we want to drag a link\n\t\t\tif (!this.diagramModel.getDiagramEngine().isModelLocked(selectedModel.model)) {\n\t\t\t\tconst relative = this.diagramModel.getDiagramEngine().getRelativeMousePoint(event);\n\t\t\t\tconst sourcePort = selectedModel.model;\n\t\t\t\tconst link = sourcePort.createLinkModel();\n\t\t\t\tlink.setSourcePort(sourcePort);\n\n\t\t\t\tif (link) {\n\t\t\t\t\tlink.removeMiddlePoints();\n\t\t\t\t\tif (link.getSourcePort() !== sourcePort) {\n\t\t\t\t\t\tlink.setSourcePort(sourcePort);\n\t\t\t\t\t}\n\t\t\t\t\tlink.setTargetPort(null);\n\n\t\t\t\t\tlink.getFirstPoint().setCoords(relative);\n\t\t\t\t\tlink.getLastPoint().setCoords(relative);\n\n\t\t\t\t\tthis.diagramModel.clearSelection();\n\t\t\t\t\tlink.getLastPoint().setSelected();\n\t\t\t\t\tthis.diagramModel.addLink(link);\n\n\t\t\t\t\tthis.startFiringAction(new MoveItemsAction(event.clientX, event.clientY, this.diagramModel.getDiagramEngine()));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.diagramModel.clearSelection();\n\t\t\t}\n\t\t} else {\n\t\t\t// its some other element, probably want to move it\n\t\t\tif (!event.shiftKey && !selectedModel.model.getSelected) {\n\t\t\t\tthis.diagramModel.clearSelection();\n\t\t\t}\n\t\t\tselectedModel.model.setSelected();\n\n\t\t\tthis.startFiringAction(new MoveItemsAction(event.clientX, event.clientY, this.diagramModel.getDiagramEngine()));\n\t\t}\n\n\t\t// create mouseMove and mouseUp listeners\n\t\tthis.mouseMoveListener = this.renderer.listen(document, 'mousemove', this.onMouseMove);\n\t\tthis.mouseUpListener = this.renderer.listen(document, 'mouseup', this.onMouseUp);\n\t}\n\n\tonMouseWheel(event: WheelEvent) {\n\t\tif (this.allowCanvasZoon) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tconst currentZoomLevel = this.diagramModel.getZoomLevel();\n\t\t\tconst oldZoomFactor = currentZoomLevel / 100;\n\t\t\tlet scrollDelta = this.inverseZoom ? -event.deltaY : event.deltaY;\n\t\t\t// check if it is pinch gesture\n\t\t\tif (event.ctrlKey && scrollDelta % 1 !== 0) {\n\t\t\t\t/* Chrome and Firefox sends wheel event with deltaY that\n\t\t\t\t   have fractional part, also `ctrlKey` prop of the event is true\n\t\t\t\t   though ctrl isn't pressed\n\t\t\t\t*/\n\t\t\t\tscrollDelta /= 3;\n\t\t\t} else {\n\t\t\t\tscrollDelta /= 60;\n\t\t\t}\n\t\t\tif (currentZoomLevel + scrollDelta > 10) {\n\t\t\t\tthis.diagramModel.setZoomLevel(currentZoomLevel + scrollDelta);\n\t\t\t}\n\n\t\t\tconst zoomFactor = this.diagramModel.getZoomLevel() / 100;\n\n\t\t\tconst boundingRect = (event.currentTarget as Element).getBoundingClientRect();\n\t\t\tconst clientWidth = boundingRect.width;\n\t\t\tconst clientHeight = boundingRect.height;\n\n\t\t\t// compute difference between rect before and after scroll\n\t\t\tconst widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n\t\t\tconst heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\n\t\t\t// compute mouse coords relative to canvas\n\n\t\t\tconst clientX = event.clientX - boundingRect.left;\n\t\t\tconst clientY = event.clientY - boundingRect.top;\n\n\t\t\t// compute width and height increment factor\n\t\t\tconst xFactor = (clientX - this.diagramModel.getOffsetX()) / oldZoomFactor / clientWidth;\n\t\t\tconst yFactor = (clientY - this.diagramModel.getOffsetY()) / oldZoomFactor / clientHeight;\n\n\t\t\tthis.diagramModel.setOffset(\n\t\t\t\tthis.diagramModel.getOffsetX() - widthDiff * xFactor,\n\t\t\t\tthis.diagramModel.getOffsetY() - heightDiff * yFactor\n\t\t\t);\n\t\t}\n\t}\n}\n"],"mappings":"AAgCA","sourceRoot":""}